JVM的类加载分为三个阶段：加载，链接和初始化。
加载：通过相应的类加载器把class文件加载到内存中
链接：分三步 校验，准备和解析
	校验：验证加载的字节码是否符合JVM规范
	准备：分配内存，为类的静态字段赋为默认值
	解析：解析引用，把符号引用解析成直接引用
初始化：主要时执行静态字段的赋值和静态代码块。 
	1.在一个类被初始化时，其父类必须先进行初始化
	2.一个类被初始化时，并不会引起其父类接口的初始化
	3.一个接口初始化时，并不会引起其父类接口的初始化
	示例代码：
public class Test {

	public static void main(String[] args) {
		System.out.println(MyChild.b);
	}
}


interface MyParent {
    int a = 5;

    Thread thread = new Thread() {
        {
            System.out.println("MyParent invoked");
        }
    };
}

class MyChild implements MyParent {
  public static   int b = 6;
}

执行结果如下：6    
由此可以看出 MyChild初始化 并不会引起父接口MyParent的初始化


类加载器


类加载器的双亲委托模式
 在加载器的双亲委托模式中，

当前类加载器:
 * 每个类都会使用自己的类加载器来去加载其他类（该类依赖的其他类）
 * 线程上下文类加载器
 * <p>
 * 从JDK1.2开始引入，类Thread的方法 getContextClassLoader与 setContextClassLoader分别用来获取和设置上下文类加载器。
 * 如果没有通过setContextClassLoader（ClassLoader cl）的话，线程将继承其父线程的上下文类加载器。
 * Java应用运行时的初始线程的上下文类加载器是系统类加载器，
 * 在线程中运行的代码会通过该类加载器来加载类与资源。
 * <p>
 * 线程上下文类加载器的重要性：
 * <p>
 * SPI(Service Provider  Interface)
 * <p>
 * 父ClassLoader可以使用当前线程Thread.Current.getContextLoader()所指定的classLoader加载的类。
 * 这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。
 * <p>
 * 线程上下文类加载器就是当前线程的Current ClassLoader。
 * <p>
 * <p>
 * 在双亲委托模型中，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口时Java核心库所提供的，
 * 而Java核心库是由启动类加载器来加载的，而这些接口的实现类却来自不同的jar包，Java的启动类加载器是不会加载其他来源的jar包，
 * 这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。
	
/**
 * @auther: kim
 * @create: 2019-10-14 12:28
 * @description: 线程上下文类加载器的一般使用模式（获取-使用-还原）
 * <p>
 * ClassLoader classLoader =Thread.currentThread().getContextClassLoader();
 * try{
 * Thread.currentThread().setContextClassLoader(myClassLoader);
 * .....执行业务...
 * }finally{
 * Thread.currentThread().setContextClassLoader(classLoader);
 * }
 * <p>
 * <p>
 * 当高层提供了统一的接口让低层区实现，同时又要在高层加载底层的类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载	该类。
 */



============================字节码===============================

1.使用javap -verbose命令分析一个字节码文件时，将会分析改字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类变量与成员变量等信息.

2.魔数：所有.class字节码文件的前4哥字节，魔数值为固定值：0xCAFEBABE。

3.魔数之后的4个字节是版本信息，前两个字节是minor version，后两个字节是major version。

4.常量池（constant pool）：紧接着major version之后就是常量池入口。一个Java类定义的很多信息都是由常量池来维护和描述的。可以将常量池看作是Class文件的资源仓库。
比如说Java类定义的方法与变量信息，都是存储在常量池中。常量池中只要存储两类常量：字面量与符号引用。字面量如文本字符串，Java中声明为final的常量值等，而符号引用
如类和接口的全局限定名，方法的名称和描述符等。

5.常量池的总体结构：Java类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池数量紧跟在主版本号后，占据两个字节；常量池数据紧跟在常量池数量之后。
常量池数组与一般的数据不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也是不同的；但是，每一种元素的第一个数据都是u1类型，该字节是个标志位，
占据1个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池中元素的个数 = 常量池数 -1 （其中0暂时不使用）。目的是满足某些常量值索引值
的数据在某些情况下需要表达 不引用任何一个常量池 的含义；根本原因在于，索引为0也是一个常量，只不过它不位于常量表中，这个常量就对应null值；所以，常量池的索引从1而非0开始。

6.在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型，方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型
和代表无返回值void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名来表示。为了压缩字节码文件的体积，对于基本类型，JVM都只使用一个大写字母来表示。
如：B - byte、C - char、D - double 、 I - int 、 J - long 、 S - short、 Z - boolean 、V - void 、 L - 对象类型，如Ljava/lang/String;

7.对于数组类型来说，每一个维度使用一个前置[来表示，如int[]被记录为[I，String[]被记录为[Ljava/lang/String;

8.用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()之内，如方法：String getNickName(int id,String name)
的描述符为：(I,Ljava/lang/String;)Ljava/lang/String


方法调用指令：
	1.invokeinterface：调用接口中的方法，实际上是在运行期决定的。决定到底调用实现该接口的哪个对象的特定方法。
	2.invokestatic：调用静态方法。
	3.invokespecial：调用自己的私有方法、构造方法以及父类方法。
	4.invokevirtual：调用虚方法，运行期动态查找的过程。
	5.invokedynamic：动态调用方法。
	
	
静态解析的4中情形：
	1.静态方法
	2.父类方法
	3.构造方法
	4.私有方法
	以上4类方法称作非虚方法，他们实在类加载阶段就可以将符号引用转化为直接引用的。


针对于方法调用的动态分派的过程，虚拟机会在类的方法区建立一个虚方法表的数据结构（vtable）
针对于invokevirtual指令来说，虚拟机会建立一个叫做接口方法的数据结构（interface method table，itable）



现代JVM在执行java代码的时候，通常都会将解释执行与编译执行二者结合起来。

所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令。
所谓编译执行，就是通过即时编译器（Just In Time）将字节码转换为本地机器码来执行；现代jvm会根据代码热点来生产相应的本地机器码。




基于栈的指令集与基于寄存器的指令集之间的关系：
	1.JVM执行指令时所采取的方式是基于栈的指令集。
	2.基于栈的指令集主要的操作有入栈与出栈两种。
	3.基于栈的指令集的优势在于可以在不同平台之间移植，而基于寄存器的指令集是与硬件架构紧密相联的，无法做到可移植性。
	4.基于栈的指令集缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多;基于栈的指令集是在内存中完成操作的，
	而基于寄存器的指令集是直接有CPU来执行的，它实在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机而已采用一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。
